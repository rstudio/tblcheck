---
title: "tblcheck"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{tblcheck}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{css echo=FALSE}
.alert {
  padding: 0.5em 1em;
  margin: 1em 2em;
  border: 1px #eee solid;
  border-radius: 5px;
}
.alert.alert-success {
  background-color: #e4f2dc;
  border-color: #ddedcf;
}
.alert.alert-success,
.alert.alert-success code,
.alert.alert-success code a:not(.close):not(.btn) {
  color: #5c9653;
}
.alert.alert-danger {
  background-color: #f2e2e2;
  border-color: #eed9dc;
}
.alert.alert-danger,
.alert.alert-danger code,
.alert.alert-danger code a:not(.close):not(.btn) {
  color: #ad3532;
}
.alert code {
  background-color: #ffffff55;
}
```

```{r, include = FALSE}
library(gradethis)
library(knitr)
library(rlang)
library(tblcheck)
library(tibble)

opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)

options(max.print = 20)

# Add hooks to turn a chunk into an unevaluated verbatim exercise chunk
# adapted from https://bookdown.org/yihui/rmarkdown-cookbook/show-header.html
knitr::knit_hooks$set(chunk_label = function(before, options) {
  # the original chunk might be indented
  indent <- options$indent %||% ""
  in_grade_this <- isTRUE(options$grade_this)
  is_exercise <- isTRUE(options$is_exercise)
  
  code <- 
    if (before) {
      c(
        sprintf(
          "```{r %s%s}",
          options$chunk_label,
          if (is_exercise) ", exercise=TRUE" else ""
        ),
        if (in_grade_this) "grade_this({"
      )
    } else {
      c(
        if (in_grade_this) "})",
        "```"
      )
    }
  
  paste0(indent, code, collapse = "\n")
})

knitr::opts_hooks$set(chunk_label = function(options) {
  options$eval <- FALSE
  options
})

og_source_hook <- knitr::knit_hooks$get("source")
knitr::knit_hooks$set(source = function(x, options) {
  if (!is.null(options$chunk_label)) {
    indent <- options$indent %||% ""
    in_grade_this <- isTRUE(options$grade_this)
    paste0(
      indent, 
      c("", paste0(if (in_grade_this) "  ", x), ""),
      collapse = "\n"
    )
  } else {
    og_source_hook(x, options)
  }
})

# approximate the appearance of a grade in a learnr tutorial
grade_html <- function(grade) {
  x <- paste0(
    '<div class="',
    if (!length(grade$correct)) {
      "alert" 
    } else if (isTRUE(grade$correct)) {
      "alert alert-success"
    } else {
      "alert alert-danger"
    },
    '">',
    grade$message,
    "</div>"
  )
  knitr::asis_output(x)
}

fake_grade_chunks <- function(
  user,
  solution = paste0(user, "-solution"),
  check = paste0(user, "-check"),
  setup = paste0(user, "-setup")
) {
  setup <- knitr::knit_code$get(setup)
  if (!is.null(setup)) {
    suppressMessages(eval(parse(text = setup), envir = .GlobalEnv))
  }
  
  force(solution)
  force(check)
  
  user <- paste0(
    ".result <- ", paste(knitr::knit_code$get(user), collapse = "")
  )
  solution <- paste0(
    ".solution <- ", paste(knitr::knit_code$get(solution), collapse = "")
  )
  check <- knitr::knit_code$get(check)
  
  env <- new.env()

  eval(parse(text = user), envir = env)
  print(env$.result)
  eval(parse(text = solution), envir = env)
  grade <- tryCatch(
    eval(parse(text = check), envir = env),
    gradethis_graded = identity
  )
  if (inherits(grade, "gradethis_graded")) return(grade_html(grade))
  if (!is.null(grade)) print(grade)
}
```

`tblcheck` provides a family of functions for creating helpful failure messages when a user's submitted code results in a table different from the intended solution.

# Basic usage

By default, `tblcheck` compares the result of the user's input to the result of the `-solution` chunk. To user `tblcheck` in the simplest case, you just need to ensure you have a `-solution` chunk and add add `tbl_grade_table()` to the grading code in you `-check` chunk, e.g.

````markdown
```{r example-check, chunk_label = "example-check", grade_this = TRUE}
pass_if_equal()
tbl_grade_table()
fail()
```
````

By default, `tblcheck` functions compare the `gradethis` objects `.result` and `.solution`, just like `gradethis::pass_if_equal()`.

## Example

In this exercise, a student is asked to use `dplyr::filter()` and `grepl()` to keep only the rows of `dplyr::storms()` where the storm was given a personal name. Then, the student is asked to use `dplyr::mutate()` and `substr()` to add a column `letter` containing the first letter of each storm's name.

````markdown
```{r storms-setup, chunk_label = "storms-setup"}
library(dplyr)
storms_ <- select(storms, name, year, month, day, hour, status, category)
```

```{r storms, chunk_label = "storms", is_exercise = TRUE}
storms_ %>% 
  mutate(named = grepl("[[:alpha:]]", name)) %>% 
  filter(named) %>% 
  mutate(name = substr(name, 1, 2))
```

```{r storms-solution, chunk_label = "storms-solution"}
storms_ %>% 
  filter(grepl("[[:lower:]]", name)) %>% 
  mutate(letter = substr(name, 1, 1))
```
````

The user's submitted table differs from the correct table in a lot of ways.
`tblcheck` always returns only one problem to the user, and tries to give the most actionable item first.

````markdown
```{r storms-check, chunk_label = "storms-check", grade_this = TRUE}
tbl_grade_table()
```
````

```{r echo=FALSE}
fake_grade_chunks("storms")
```

Here, `tbl_grade_table()` first highlights the incorrect column name in the user's code, because the user added an unnecessary column, `named` and overwrote the existing column `name` instead of creating a new `letter` column. Let's see what happens when the user fixes this.

````markdown
```{r storms_2, chunk_label = "storms", is_exercise = TRUE}
storms_ %>% 
  mutate(name = grepl("[[:alpha:]]", name)) %>% 
  filter(name) %>% 
  mutate(letter = substr(name, 1, 2))
```

```{r storms_2-check, chunk_label = "storms-check", grade_this = TRUE}
tbl_grade_table()
```
````

```{r echo=FALSE}
fake_grade_chunks("storms_2", solution = "storms-solution")
```

`tbl_grade_table()` now informs the user that they don't have the right number of rows, because they did not use the correct regex pattern to filter the data.

````markdown
```{r storms_3, chunk_label = "storms", is_exercise = TRUE}
storms_ %>% 
  mutate(name = grepl("[[:lower:]]", name)) %>% 
  filter(name) %>% 
  mutate(letter = substr(name, 1, 2))
```

```{r storms_3-check, chunk_label = "storms-check", grade_this = TRUE}
tbl_grade_table()
```
````

```{r echo=FALSE}
fake_grade_chunks("storms_3", solution = "storms-solution")
```

Next, the user finds out their column contains the wrong type of data, since they overwrote the `name` column.

````markdown
```{r storms_4, chunk_label = "storms", is_exercise = TRUE}
storms_ %>% 
  filter(grepl("[[:lower:]]", name)) %>% 
  mutate(letter = substr(name, 1, 2))
```

```{r storms_4-check, chunk_label = "storms-check", grade_this = TRUE}
tbl_grade_table()
```
````

```{r echo=FALSE}
fake_grade_chunks("storms_4", solution = "storms-solution")
```

If all else fails, `tbl_grade_table()` gives a hint as to what the user's values should look like: they extracted the first two letters of the name instead of the first letter.

````markdown
```{r storms_5, chunk_label = "storms", is_exercise = TRUE}
storms_ %>% 
  filter(grepl("[[:lower:]]", name)) %>% 
  mutate(letter = substr(name, 1, 1))
```

```{r storms_5-check, chunk_label = "storms-check", grade_this = TRUE}
tbl_grade_table()
```
````

```{r echo=FALSE}
fake_grade_chunks("storms_5", solution = "storms-solution")
```

When everything is correct, `tbl_grade_table()` gives no output. It doesn't return a passing grade in case you have other checks you'd like to run. Be sure to include a `gradethis` function like `pass()` or `pass_if_equal()` in your checking code to ensure students can get a passing grade!

# Grading vectors

For exercises that use vectors rather than tables, `tbl_grade_vector()` allows you to apply the same tests that are normally applied to the columns of a table. For example:

````markdown
```{r vector-setup, chunk_label = "vector-setup"}
library(dplyr)
storm_names <- storms$name
```

```{r vector, chunk_label = "vector", is_exercise = TRUE}
grep(storm_names, "[[:lower:]]")
```

```{r vector-solution, chunk_label = "vector-solution"}
grepl(storm_names, "[[:lower:]]")
```

```{r vector-check, chunk_label = "vector-check", grade_this = TRUE}
tbl_grade_vector()
```
````

```{r echo=FALSE}
fake_grade_chunks("vector")
```

Here, the user gets feedback that their vector is the wrong type, because they used `grep()` instead of `grepl()`.

# Other grading functions

`tbl_grade_table()` and `tbl_grade_vector()` calls a number of grading functions internally. You can call these functions directly to perform more specific grading.

- `tbl_grade_column()` grades a single column of a table.
- `tbl_grade_class()` grades the class of an object.
- `tbl_grade_length()` grades the `length`, `ncol`, or `nrow` of an object.
- `tbl_grade_names()` grades the names of an object.

# Skipping tests

If there are some tests you would like to skip, `tbl_grade_table()` includes a host of arguments that can be set to `FALSE`. For example:

````markdown
```{r numbers, chunk_label = "numbers", is_exercise = TRUE}
data.frame(numbers = 1:5) %>% 
  mutate(even = numbers %% 2 == 0)
```

```{r numbers-solution, chunk_label = "storms-solution"}
tibble(numbers = 1:5) %>% 
  mutate(even = numbers %% 2 == 0)
```

```{r numbers-check, chunk_label = "storms-check", grade_this = TRUE}
tbl_grade_table()
```
````

```{r echo=FALSE}
fake_grade_chunks("numbers")
```

When the user's result is a different class than the expected solution, `tbl_grade_table()` gives a failing grade. If you don't care about the class of the table, you can add `check_class = FALSE`.

````markdown
```{r numbers_2-check, chunk_label = "storms-check", grade_this = TRUE}
tbl_grade_table(check_class = FALSE)
```
````

```{r echo=FALSE}
fake_grade_chunks("numbers", check = "numbers_2-check")
```

Since there are no other problems, we get no output.

Every test performed by `tbl_grade_table()` or `tbl_grade_vector()` can be disabled with an argument. 

# Custom mistake handling

Sometimes, we want to give special handling to a specific circumstance. For example, in this exercise, a student is instructed to use `dplyr::mutate()`, `paste()`, and `as.Date()` create a new column in the `storms_` data named `date`.

````markdown
```{r date, chunk_label = "date", is_exercise = TRUE}
storms_ %>% 
  mutate(date = paste(year, month, day, sep = "-"))
```

```{r date-solution, chunk_label = "date-solution"}
storms_ %>% 
  mutate(date = as.Date(paste(year, month, day, sep = "-")))
```

```{r date-check, chunk_label = "date-check", grade_this = TRUE}
tbl_grade_table()
```
````

```{r echo=FALSE}
fake_grade_chunks("date")
```

If this is a mistake you expect a lot of students to make, you may want to give it special handling. `tbl_check_table()` returns a problem object that you can inspect in your grading code.

````markdown
```{r date_2-check, chunk_label = "date-check", grade_this = TRUE}
tbl_check_table()
```
````

```{r echo=FALSE}
fake_grade_chunks("date", check = "date_2-check")
```

You can use `if` statements to give specific feedback based on the nature of the problem object. To apply the default grading code of `tbl_grade_table()`, you can use `tbl_grade()` on the `problem` object.

````markdown
```{r date_3-check, chunk_label = "date-check", grade_this = TRUE}
problem <- tbl_check_table()

if (problem$type == "column_class" && problem$actual == "Date") {
  fail("I expected you to create a Date. Did you remember to use `as.Date`?")
} else {
  tbl_grade(problem)
}
```
````

```{r echo=FALSE}
fake_grade_chunks("date", check = "date_3-check")
```

**Tip**: You can also use `if` statements to ignore differences that you don't care about in your grading code.

Applying the same code to a different mistake, we retain the normal `tbl_grade_table()` functionality, like in this example where the student gave the column the wrong name the day and month:

````markdown
```{r date_4, chunk_label = "date", is_exercise = TRUE}
storms_ %>% 
  mutate(time = as.Date(paste(year, month, day, sep = "-")))
```
````

```{r echo=FALSE}
fake_grade_chunks("date_4", "date-solution", "date_3-check")
```

All `tbl_grade_*()` functions have a `tbl_check_*()` equivalent, allowing you to add custom handling for any detected mistake.
